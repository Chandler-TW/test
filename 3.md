**标题：掌握 C++ 向量和链表编程**<br>


**描述：**

本培训模块将带您领略 C++数据结构的强大之处，向量和链表作为典型的数据结构类型，是本篇重点介绍的对象，同时，由于向量和链表的使用会涉及大量的面相对象和指针的使用，所以我们将通过逐步练习面向对象编程、指针，然后再到向量和链表的使用，让您轻松驾驭C++数据结构的编程世界。  

**学习目标：**

-   理解面向对象编程 (OOP) 的核心概念及其在 C++ 中的应用。

-   掌握指针的使用方法，灵活操控内存。

-   熟练运用向量 (vector) 进行高效的动态数组操作。

-   深入理解链表 (list) 的结构，实现灵活的内存管理。

-   结合面向对象、指针、向量和链表，完成综合性编程任务。


**准备出发：**

在开始学习之前，确保您已经具备基本的 C++语法基础，熟悉变量的使用。掌握循环和条件语句将使您的学习更加轻松。让我们开始吧！

以下实践单元将带领您从基础的面向对象编程开始，再到指针的练习，然后逐步攻克向量和链表的 C++ 编程实践，最后一项挑战是一个集合了向量和链表的综合练习。

> 每个练习都提供了基本的学习资料，建议先浏览每个练习里的学习资料，掌握基本的概念后再开始每个练习。<br><br>

**实践 1：面向对象编程入门 (OOP)**

**1.1 业务需求**

设计一个简单类 (class) 来表示学生的信息，并包含相关操作方法。

**1.2 技术需求**

-   定义类来封装学生信息 (姓名、学号等)。

-   实现成员变量和成员函数的概念。

**1.3 学习资料**

-   C++ 面向对象编程基础：https://www.learncpp.com/cpp-tutorial/introduction-to-object-oriented-programming/

**1.4 测试方法**

创建学生对象，测试成员变量的访问和成员函数的调用。

**1.5 示例代码**

```c++
#include <iostream>

class Student {
public:
  std::string name;
  int id;

  void introduce() {
    std::cout << "Hello, my name is " << name << " and my ID is " << id << std::endl;
  }
};

int main() {
  Student alice;
  alice.name = "Alice";
  alice.id = 12345;
  alice.introduce();

  return 0;
}
```

**1.6 关键收获**

-   理解类、对象、成员变量和成员函数的概念。

-   掌握面向对象编程的基本思想。

**1.7 拓展阅读**

-   继续阅读学习资料中的更多内容，探索继承、多态等面向对象高级特性。
<br><br>

**实践 2：指针利器 - 操控内存进阶**

**2.1 业务需求**

运用指针变量来操作内存地址，实现数据传递和动态内存分配。

**2.2 技术需求**

-   理解指针的概念及其基本语法 (地址运算符 &, 解引用运算符 \*)。

-   学习如何使用指针传递函数参数。

-   掌握动态内存分配 (new & delete) 的用法。

**2.3 学习资料**

-   C++ 指针详解：https://www.learncpp.com/cpp-tutorial/introduction-to-pointers/

**2.4 测试方法**

编写函数交换两个整数的值，分别使用值传递和指针传递进行测试，对比两种方式的区别。

**2.5 示例代码**

```c++
#include <iostream>

void swapValues(int a, int b) { // 值传递 (不会改变原值)
  int temp = a;
  a = b;
  b = temp;
}

void swapPointers(int* a, int* b) { // 指针传递 (会改变原值)
  int temp = *a;
  *a = *b;
  *b = temp;
}

int main() {
  int x = 5, y = 10;
  std::cout << "Before swap (value): x = " << x << ", y = " << y << std::endl;
  swapValues(x, y);
  std::cout << "After swap (value): x = " << x << ", y = " << y << std::endl;

  int* ptrX = &x; // ptrX 指向 x 的内存地址
  int* ptrY = &y; // ptrY 指向 y 的内存地址
  std::cout << "Before swap (pointer): x = " << x << ", y = " << y << std::endl;
  swapPointers(ptrX, ptrY);
  std::cout << "After swap (pointer): x = " << x << ", y = " << y << std::endl;

  // 动态内存分配示例
  int* data = new int; // 分配一块内存并返回指针
  *data = 20;
  std::cout << "Value stored in dynamically allocated memory: " << *data << std::endl;
  delete data; // 释放分配的内存空间

  return 0;
}

```

**2.6 关键收获**

-   掌握指针的基本用法，操控内存地址。

-   理解值传递和指针传递的区别。

-   学会使用动态内存分配进行灵活的内存管理。

**2.7 拓展阅读**

-   继续阅读学习资料中的更多内容，探索指针运算 (指针加减、数组指针) 的高级用法。<br><br>


**实践 3：向量纵横 - 动态数组得心应手**

**3.1 业务需求**

运用向量 (vector) 来存储和管理可变长度的元素集合。

**3.2 技术需求**

-   理解向量 (vector) 的基本操作
    (创建、访问元素、大小获取、添加/删除元素等)。

-   学习使用迭代器 (iterator) 遍历向量元素。

**3.3 学习资料**

-   C++ STL vector 介绍：https://coding-champ.com/tutorials/c-plus-plus/vectors

**3.4 测试方法**

编写程序，使用向量存储一组学生成绩，并实现计算平均分等功能。

**3.5 示例代码**

```c++
#include <iostream>
#include <vector>

int main() {
  std::vector<int> scores; // 创建一个空向量

  scores.push_back(90); // 添加元素到向量尾部
  scores.push_back(85);
  scores.push_back(78);

  std::cout << "Number of scores: " << scores.size() << std::endl; // 获取向量大小

  int sum = 0;
  for (int score : scores) { // 遍历向量元素 (使用范围循环)
    sum += score;
  }

  double average = static_cast<double>(sum) / scores.size();
  std::cout << "Average score: " << average << std::endl;

  return 0;
}
```

**3.6 关键收获**

-   掌握向量存储和操作可变长度数据的便捷性。

-   理解迭代器遍历向量的用法。

**3.7 拓展阅读**

-   继续阅读学习资料中的更多内容，探索向量排序、查找等高级操作。<br><br>

**实践 4：链表奥秘 - 灵活内存管理新体验**

**4.1 业务需求**

运用链表 (list) 来构建一种灵活的线性数据结构，实现高效的插入和删除操作。

**4.2 技术需求**

-   理解链表的基本概念 (节点结构、头指针、尾指针)。

-   学习如何创建链表、插入/删除节点。

-   掌握链表的遍历操作。

**4.3 学习资料**

-   C++ 链表详解：https://coding-champ.com/tutorials/c-plus-plus/lists

**4.4 测试方法**

编写程序，使用链表存储一组歌名，并实现歌曲的插入和删除功能。

**4.5 示例代码**

```c++
#include <iostream>

struct SongNode {
  std::string title;
  SongNode* next; // 指向下一个节点
};

SongNode* head = nullptr; // 头指针，初始为空

// 添加歌曲节点到链表尾部
void addSong(std::string title) {
  SongNode* newNode = new SongNode; // 创建新节点
  newNode->title = title;
  newNode->next = nullptr;

  if (head == nullptr) {
    head = newNode;
  } else {
    SongNode* current = head;
    while (current->next != nullptr) {
      current = current->next;
    }
    current->next = newNode;
  }
}

// 删除指定标题的歌曲节点
void deleteSong(std::string title) {
  if (head == nullptr) return;

  SongNode* current = head;
  SongNode* prev = nullptr;

  while (current != nullptr && current->title != title) {
    prev = current;
    current = current->next;
  }

  if (current == nullptr) {
    std::cout << "Song not found." << std::endl;
    return;
  }

  if (prev == nullptr) { // 删除头节点
    head = current->next;
  } else {
    prev->next = current->next;
  }

  delete current; // 释放已删除节点的内存
}

// 遍历链表并打印歌曲信息
void printSongs() {
  SongNode* current = head;
  while (current != nullptr) {
    std::cout << current->title << std::endl;
    current = current->next;
  }
}

int main() {
  // 测试代码
  addSong("Imagine");
  addSong("Bohemian Rhapsody");
  addSong("Hotel California");

  printSongs(); // 打印链表内容

  deleteSong("Bohemian Rhapsody");

  printSongs(); // 再次打印链表内容 (已删除 Bohemian Rhapsody)

  return 0;
}
```

**4.6 关键收获**

-   理解链表的结构和操作方法。

-   掌握链表的插入和删除操作的灵活特性。

**4.7 拓展阅读**

-   继续阅读学习资料中的更多内容，探索单链表和双链表的区别。

-   学习使用链表实现栈和队列等高级数据结构。<br><br>

**5. 综合挑战：图书借阅管理系统**

现在，让我们挑战一下！结合前面学习的面向对象、指针、向量和链表知识，设计并实现一个程序，管理图书借阅信息。程序需要存储图书信息
(书名、作者等) 和借阅人信息 (姓名、学号等)，并提供图书借阅/归还等功能。

**情景:**

开发一个图书借阅管理系统，可以存储图书信息 (书名、作者、ISBN 等)
和借阅人信息
(姓名、学号、借阅日期等)。系统需要支持图书添加、删除、查询、借阅和归还等功能。

**提示:**

-   可以分别使用类来封装图书和借阅人信息。

-   考虑使用向量存储图书和借阅人列表。

-   指针可以帮助间接访问对象成员。

> 通过这个综合性挑战，您将融会贯通 C++ 的强大编程能力！

**示例代码 (核心功能片段):**

```c++
#include <iostream>
#include <vector>
#include <string>

class Book {
public:
  std::string title;
  std::string author;
  std::string isbn;
  bool isAvailable; // 标识图书是否可用 (未借出)

  // ... 其他成员函数 (构造函数、获取信息等)
};

class Borrower {
public:
  std::string name;
  int id;
  std::vector<Book*> borrowedBooks; // 借阅人借阅的图书列表 (指针)

  // ... 其他成员函数 (构造函数、获取信息等)
};

std::vector<Book> books; // 存储所有图书信息的向量
std::vector<Borrower> borrowers; // 存储所有借阅人信息的向量

// 函数原型 (具体实现略)
void addBook(const Book& book);
void deleteBook(const std::string& isbn);
void findBook(const std::string& title);
void borrowBook(const std::string& isbn, Borrower& borrower);
void returnBook(const std::string& isbn, Borrower& borrower);

int main() {
  // ... 主程序 (菜单驱动，调用上述函数实现图书借阅管理)

  return 0;
}

// 函数实现示例 (以 borrowBook 为例)
void borrowBook(const std::string& isbn, Borrower& borrower) {
  for (Book& book : books) {
    if (book.isbn == isbn && book.isAvailable) {
      book.isAvailable = false;
      borrower.borrowedBooks.push_back(&book);
      std::cout << "Book borrowed successfully!" << std::endl;
      return;
    }
  }
  std::cout << "Book not found or unavailable." << std::endl;
}
```

**注意:**

-   此示例代码仅展示了部分核心功能的实现片段，完整程序需要涵盖更多细节
    (错误处理、用户交互界面等)。

-   借阅书籍时，使用指针将图书对象添加到借阅人借阅的图书列表中，体现了指针间接访问对象成员的用法。<br><br>

**使用 GTest 测试示例代码**<br><br>
下面使用Gtest测试“综合挑战：图书借阅管理系统”示例代码中的各个功能模块。下面将介绍如何编写测试用例：

1. 头文件包含

在测试文件中，首先需要包含 gtest/gtest.h 头文件以及您要测试的代码的相应头文件：

```c++
#include <gtest/gtest.h>
#include "Book.h"  // 假设您的图书类叫做 Book
#include "Borrower.h" // 假设您的借阅人类叫做 Borrower
// 其他相关头文件
```

2. 测试类定义

创建一个继承自 testing::Test 的测试类，用来存放针对图书借阅管理系统的各种测试用例。

```c++
class LibraryManagementTest : public ::testing::Test {
protected:
  // 可选：在此处设置测试前置/后置操作 (例如，创建测试用的图书和借阅人对象)
};
```

3. 测试用例编写

使用 TEST_F 宏来定义各个测试用例。每个测试用例都应该以测试的特定功能为导向，并遵循以下结构：

安排 (Arrange)： 设置测试所需的初始状态，例如创建图书和借阅人对象。
行动 (Act)： 调用要测试的函数或方法，模拟用户操作。
断言 (Assert)： 使用 EXPECT_* 宏来验证预期的行为是否发生。
示例测试用例：

```c++
TEST_F(LibraryManagementTest, AddBookTest) {
  // 安排
  Book book;
  book.title = "C++ Primer";
  book.author = "Stanley B. Lippman";
  book.isbn = "978-0134678293";
  book.isAvailable = true;

  // 行动
  addBook(book); // 假设 addBook 是用于添加图书的函数

  // 断言
  ASSERT_EQ(books.size(), 1);  // 检查图书列表是否增加了一本
  EXPECT_EQ(books[0].title, book.title);  // 检查添加的图书信息是否正确
}

TEST_F(LibraryManagementTest, BorrowBookTest) {
  // 安排
  Book book;
  book.title = "The Lord of the Rings";
  book.author = "J.R.R. Tolkien";
  book.isbn = "978-0547928225";
  book.isAvailable = true;
  addBook(book);

  Borrower borrower;
  borrower.name = "Alice";
  borrower.id = 12345;

  // 行动
  borrowBook(book.isbn, borrower);

  // 断言
  EXPECT_FALSE(book.isAvailable);  // 检查图书是否被标记为不可用
  ASSERT_EQ(borrower.borrowedBooks.size(), 1);  // 检查借阅人借阅列表是否增加了一本
  EXPECT_EQ(borrower.borrowedBooks[0]->title, book.title);  // 检查借阅的图书信息是否正确
}

// 编写更多测试用例涵盖其他功能，例如归还图书、查询图书等
```
4. 编译和运行测试

使用合适的编译器 (例如 g++ ) 编译您的测试代码和 gtest 库，然后运行可执行文件即可执行测试用例。确保您已经将 gtest 库链接到您的可执行文件中。

提示：

编写测试用例时，要覆盖尽可能多的场景，包括正常情况和异常情况。
可以使用不同的测试夹具 (TestFixture) 来组织相关的测试用例。
善用 EXPECT_* 宏的不同类型 (例如 EXPECT_TRUE, EXPECT_EQ) 来进行丰富的断言。
通过使用 GTest，您可以编写健壮的测试用例，确保图书借阅管理系统的各个功能的正确性。

**通过完成此综合挑战，您可以将面向对象、指针、向量和链表的知识融会贯通，并将其应用于实际的C++ 程序设计中！**<br>
> 更多学习内容可参考：https://www.learncpp.com/cpp-tutorial/introduction-to-stdvector-and-list-constructors/
